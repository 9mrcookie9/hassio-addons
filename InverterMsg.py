import struct  # Converting bytes to numbers
import re
import binascii
import pprint

# V5 table
offset = {
    1: 1,  # len(1)
    2: 12,  # msg(12)
    3: 32,  # id(32)
    4: 48,  # temperature(31)
    5: 50,  # v_pv(50,52)
    6: 54,  # i_pv(54,56)
    7: 58,  # i_ac(58,60,62)
    8: 64,  # v_ac(64,66,68)
    9: 70,  # f_ac(70)
    10: 72,  # p_ac/power(72)
    11: 76,  # e_today(76)
    12: 80,  # e_total(71)
}
    #?    13: 84,  # h_total(75)
    #?    14: 79,  # run_state(79)
    #?    15: 81,  # GVFaultValue(81)
    #?    16: 83,  # GVFaultValue(83)
    #?    17: 85,  # GZFaultValue(85)
    #?    18: 87,  # TmpFaultValue(87)
    #?    19: 89,  # PVFaultValue(89)
    #?    20: 91,  # GFCIFaultValue(91)
    #?    21: 93,  # errorMsg(93)
    #?    22: 101,  # main_fwver(101)
    #?    23: 121, }  # slave_fwver(121)


class InverterMsg(object):
    """Decode the response message from an inverter logger."""
    raw_msg = ""

    def __init__(self, msg, offset=0):
        self.raw_msg = msg
        self.offset = offset

    def __get_string(self, begin, end):
        """Extract string from message.

        Args:
            begin (int): starting byte index of string
            end (int): end byte index of string

        Returns:
            str: String in the message from start to end
        """
        return self.raw_msg[begin:end].decode('cp437')

    #
    def __get_int(self, begin):
        """Extract byte value from message.

        Args:
            begin (int): starting byte index of string

        Returns:
            int: value at offset
        """
        if (len(self.raw_msg) < begin):
            return 0
        return int(binascii.hexlify(bytearray(self.raw_msg[begin:begin + 1])), 16)

    #
    def __get_short(self, begin, divider=10):
        """Extract short from message.

        The shorts in the message could actually be a decimal number. This is
        done by storing the number multiplied in the message. So by dividing
        the short the original decimal number can be retrieved.

        Args:
            begin (int): index of short in message
            divider (int): divider to change short to float. (Default: 10)

        Returns:
            int or float: Value stored at location `begin`
        """
        num = struct.unpack('!H', self.raw_msg[begin:begin + 2][::-1])[0]
        if num > 32767:
            return float(-(65536 - num)) / divider
        else:
            return float(num) / divider

    def __get_long(self, begin, divider=10):
        """Extract long from message.

        The longs in the message could actually be a decimal number. By
        dividing the long, the original decimal number can be extracted.

        Args:
            begin (int): index of long in message
            divider (int): divider to change long to float. (Default : 10)

        Returns:
            int or float: Value stored at location `begin`
        """
        return float(
            struct.unpack('!I', self.raw_msg[begin:begin + 4][::-1])[0]) / divider

    @property
    def len(self):
        """received data len msg."""
        return self.__get_int(offset[1])

    @property
    def msg(self):
        """received status msg."""
        return self.__get_string(offset[2], self.len + offset[2])

    @property
    def id(self):
        """ID of the inverter."""
        return self.__get_string(offset[3],
                                 offset[3] + 16).lstrip().rstrip()  # Strip spaces from shorter or padded inverter SN

    @property
    def temp(self):
        """Temperature recorded by the inverter."""
        return self.__get_short(offset[4], 10)

    @property
    def e_today(self):
        """Energy generated by inverter today in kWh"""
        return self.__get_short(offset[11], 100)  # Divide by 100

    @property
    def e_total(self):
        """Total energy generated by inverter in kWh"""
        return self.__get_long(offset[12])

    # @property
    # def h_total(self):
    #     """Hours the inverter generated electricity"""
    #     return int(self.__get_long(offset[13], 10))  # Don't divide
    #
    # @property
    # def run_state(self):
    #     """RUN State"""
    #     return int(self.__get_short(offset[14], 1))
    #
    # @property
    # def GVFaultValue(self):
    #     """Grid voltage fault value in V"""
    #     return self.__get_short(offset[15], 10)  # Divide by 10
    #
    # @property
    # def GVFaultValue(self):
    #     """Grid frequency fault value in Hz"""
    #     return self.__get_short(offset[16], 100)  # Divide by 100
    #
    # @property
    # def GZFaultValue(self):
    #     """Grid impedance fault value in Ohm"""
    #     return self.__get_short(offset[17], 1000)  # Divide by 1000
    #
    # @property
    # def TmpFaultValue(self):
    #     """Temperature fault value in oC"""
    #     return self.__get_short(offset[18], 10)  # Divide by 10
    #
    # @property
    # def PVFaultValue(self):
    #     """PV voltage fault value in V"""
    #     return self.__get_short(offset[19], 10)  # Divide by 10
    #
    # @property
    # def GFCIFaultValue(self):
    #     """GFCI current fault value in A"""
    #     return self.__get_short(offset[20], 1000)  # Divide by 1000
    #
    # @property
    # def errorMsg(self):
    #     """errorMsg binary index value"""
    #     return int(self.__get_long(offset[21]))
    #
    # @property
    # def main_fwver(self):
    #     """Inverter main firmware version."""
    #     if (self.__get_int(offset[22]) == 0): return ""
    #     return re.sub('[^\x20-\x7f]', '', self.__get_string(offset[22], offset[22] + 19))
    #
    # @property
    # def slave_fwver(self):
    #     """Inverter slave firmware version."""
    #     if (self.__get_int(offset[23]) == 0): return ""
    #     return re.sub('[^\x20-\x7f]', '', self.__get_string(offset[23], offset[23] + 19))

    def v_pv(self, i=1):
        """Voltage of PV input channel.

        Available channels are 1, 2; if not in this range the function will
        default to channel 1.

        Args:
            i (int): input channel (valid values: 1, 2)

        Returns:
            float: PV voltage of channel i
        """
        if i not in range(1, 3):
            i = 1
        num = offset[5] + (i - 1) * 2
        return self.__get_short(num)

    def i_pv(self, i=1):
        """Current of PV input channel.

        Available channels are 1, 2; if not in this range the function will
        default to channel 1.

        Args:
            i (int): input channel (valid values: 1, 2)

        Returns:
            float: PV current of channel i
        """
        if i not in range(1, 3):
            i = 1
        num = offset[6] + (i - 1) * 2
        return self.__get_short(num)

    def i_ac(self, i=1):
        """Current of the Inverter output channel

        Available channels are 1, 2 or 3; if not in this range the function will
        default to channel 1.

        Args:
            i (int): output channel (valid values: 1, 2, 3)

        Returns:
            float: AC current of channel i

        """
        if i not in range(1, 4):
            i = 1
        num = offset[7] + (i - 1) * 2
        return self.__get_short(num)

    def v_ac(self, i=1):
        """Voltage of the Inverter output channel

        Available channels are 1, 2 or 3; if not in this range the function will
        default to channel 1.

        Args:
            i (int): output channel (valid values: 1, 2, 3)

        Returns:
            float: AC voltage of channel i
        """
        if i not in range(1, 4):
            i = 1
        num = offset[8] + (i - 1) * 2
        return self.__get_short(num)

    def f_ac(self, i=1):
        """Frequency of the output channel

        Returns:
            float: AC frequency of channel i
        """
        return self.__get_short(offset[9], 100)

    def p_ac(self):
        """Power output of the output channel

        Returns:
            float: Power output of channel i
        """
        return int(self.__get_short(offset[10], 1))  # Don't divide

    def dict(self):
        d = {'id': self.id, "temp": self.temp}
        d["v_pv" + str(1)] = self.v_pv(1)
        d["v_pv" + str(2)] = self.v_pv(2)
        d["i_pv" + str(1)] = self.i_pv(1)
        d["i_pv" + str(2)] = self.i_pv(2)
        d["v_ac" + str(1)] = self.v_ac(1)
        d["v_ac" + str(2)] = self.v_ac(2)
        d["v_ac" + str(3)] = self.v_ac(3)
        d["i_ac" + str(1)] = self.i_ac(1)
        d["i_ac" + str(2)] = self.i_ac(2)
        d["i_ac" + str(3)] = self.i_ac(3)
        d["f_ac"] = self.f_ac()
        d["power"] = self.p_ac()
        d["e_today"] = self.e_today
        d["e_total"] = self.e_total
        return d

def debugMsg(data):
    data = data.replace(':', '')
    msg = InverterMsg(bytearray.fromhex(data))
    pp = pprint.PrettyPrinter()
    pp.pprint(msg.dict())
    print "#######################################################################"


if __name__ == '__main__':
    debugMsg("a5:8d:00:10:42:50:62:2d:bf:c8:65:01:01:27:5c:50:19:00:5b:1c:00:00:44:26:63:5e:01:00:e8:15:00:00:53:46:34:45:53:30:30:38:4b:42:32:31:33:33:20:20:9a:01:dd:0c:75:0c:2d:00:2b:00:29:00:29:00:29:00:f5:08:eb:08:ee:08:88:13:c8:0a:00:00:1f:02:00:00:2e:18:00:00:b6:01:00:00:02:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:56:32:30:30:56:31:30:30:1d:00:60:18:d1:0c:71:0c:3c:00:01:00:56:05:54:08:b3:06:0c:00:00:00:00:00:06:00:e7:03:e0:03:d9:03:00:00:00:00:00:00:00:00:3c:15")
